
ClassModel:
    'class' 'model' (name=ID) ?
    OPTTB ';'
    declarations *= Declaration
;


Declaration:
      EntityDefinition
    | SpeechDeclaration
;

EntityDefinition:
      Enumeration
    | Class
    | Association
    | Invariant
;

//----------------------------------------------------------

Enumeration:
    'enumeration' name=ID '{'
        textBlock = TextBlock
        literals += EnumerationLiteral
    '}' ';'
;

EnumerationLiteral:
    name=ID ';'
;


//----------------------------------------------------------

Class:  // common
    'class' name=ID ('<' superclass=ID) ?
    ('{'
        (textBlock = TextBlock)?
        attributeCompartment=AttributesCompartment ?
        operationCompartment=OperationsCompartment ?
        invariantCompartment=InvariantsCompartment ?
        permissionCompartment=PermissionsCompartment ?
    '}')?
    ';'
;

AttributesCompartment:  // common
    'attributes'
    ('{'
        attributes += Attribute
    '}')?
    ';'
;

Attribute:
    '/' ? name=ID ':' type=ID (cardinality=Cardinality) ?
    OPTTB
    ';'
;

OperationsCompartment:
    'operations' '{'
        operations *= Operation
    '}'
    ';'
;

Operation:
    name=ID
    '('
        arguments*=Argument[',']
    ')'
    (':' returnType=ID)?
    OPTTB
    ';'

;

Arguments:
    arguments *= Argument[',']
;


Argument:
    name=ID ':' type=ID
;

InvariantsCompartment:
    'invariants' ';'
;

PermissionsCompartment:
    'permissions' ';'
;


//----------------------------------------------------------


Association:
    kind=AssociationKind '{'
    roleCompartment=RoleCompartment
    attributeCompartment=AttributesCompartment ?
    operationCompartment=OperationsCompartment ?
    '}' ';'
;

AssociationKind:
      'association'
    | 'composition'
    | 'aggregation'
;

RoleCompartment:
    'roles' '{'
    from=Role
    to=Role
    '}' ';'
;

Role:
    name=ID ':' class=[Class] cardinality=Cardinality ? ';'
;

//----------------------------------------------------------

Invariant:
    'invariant' ';'
;

Cardinality:
//    '[' max='*' ']'
//    | '[' min=CardinalityMin ']'
//    | '[' min=CardinalityMin ? ('..' max=CardinalityMax)? ']'
   '[' min=Multiplicity ? ('..' max=Multiplicity) ? ']'
;

Multiplicity:
    INT | '*'
;



SpeechDeclaration:
      SpeechClassDefinition
    | SpeechInheritance
    | SpeechAttributeDefinition
    | SpeechAssocForwardDefinition
    | SpeechAssocConstraint
;


SpeechClassDefinition:
      FRClassDefinition
    | ENClassDefinition
;

FRClassDefinition:
    'Le' 'concept' 'de' class=ID  'est' 'important' '.'
    ';'
;

ENClassDefinition:
    'The' 'concept' 'of' class=ID 'is' 'important' '.'
    ';'
;

SpeechInheritance:
      FRClassInheritance
    | ENClassInheritance
;

FRClassInheritance:
    Un_ class=ID 'est' un_ superclass=ID '.'
    ';'
;

ENClassInheritance:
    A_ class=ID 'is' a_ superclass=ID '.'
    ';'
;

SpeechAttributeDefinition:
      FRAttributeDefinition
    | ENAttributeDefinition
;

FRAttributeDefinition:
    Le_ attribute=ID d_un_ class=ID 'est' un_ type=ID '.' ';'
;

ENAttributeDefinition:
    'The' attribute=ID 'of' a_ class=ID 'is' a_ type=ID '.' ';'
;

SpeechAssocForwardDefinition:
      ENAssocForwardDefinition
    | FRAssocForwardDefinition
;

ENAssocForwardDefinition:
    A_ class1=ID
    association=ID
    'of'? cardinality=SpeechAssocCardinality
    role2=ID
    'of'? 'type' class2=ID
    '.'
    ';'
;

FRAssocForwardDefinition:
    Un_ class1=ID
    association=ID
    de_? cardinality=SpeechAssocCardinality
    role2=ID
    de_? 'type' class2=ID
    '.'
    ';'
;


SpeechAssocReverseDefinition:
      ENAssocReverseDefinition
    | FRAssocReverseDefinition
;

ENAssocReverseDefinition:
    A_ class2=ID
    'has' cardinality=SpeechAssocCardinality
    role1=ID
    'of' 'type' class1=ID
    '.'
    ';'
;

FRAssocReverseDefinition:
    Un_ class2=ID
    'a' cardinality=SpeechAssocCardinality
    role1=ID
    'de' 'type' class1=ID
    '.'
    ';'
;

SpeechAssocCardinality:
      SpeechAssocCardinality_0N
    | SpeechAssocCardinality_1N
    | SpeechAssocCardinality_01
    | SpeechAssocCardinality_1
    | SpeechAssocCardinality_XY
;

SpeechAssocCardinality_0N:
      ('zero' 'or' 'many')
    | ('zero' 'ou' 'plusieurs')
;

SpeechAssocCardinality_1N:
      ('one' 'or' 'many')
    | (('un'|'une') 'ou' 'plusieurs')
;

SpeechAssocCardinality_01:
      ('zero' 'or' 'one')
    | ('zero' 'ou' un_)
;

SpeechAssocCardinality_1:
      'one'
    | un_
;

SpeechAssocCardinality_XY:
      ('between' min=INT 'and' max=INT)
    | ('entre' min=INT 'et' max=INT)
;


SpeechAssocConstraint:
      ENAssocConstraint
    | FRAssocConstraint
;

ENAssocConstraint:
    'If' var2a=ID
    'is' card2=ENAssocConstraintCardinality
    role2=ID
    'of' 'a' class1=ID
    var1a=ID
    '{'
        'then' var1b=ID
        'is' card1=ENAssocConstraintCardinality
        role1=ID
        'of' ( 'the' class2=ID )
        var2b=ID
        '.'
        ';'
    '}'
    ';'
;

ENAssocConstraintCardinality:
      'the'
    | 'one' 'of' 'the'
;

FRAssocConstraint:
    'Si' var2a=ID
    'est' card2=FRAssocConstraintCardinality
    role2=ID
    d_un_ class1=ID
    var1a=ID
    '{'
        'alors' var1b=ID
        'est' card1=FRAssocConstraintCardinality
        role1=ID
        (     (du_ class2=ID var2b=ID)
            | ('de' var2b=ID)
            )
        '.'
        ';'
    '}'
    ';'
;


FRAssocConstraintCardinality:
      le_
    | "l'" un_ 'des'
;

Le_:
    'Le' | 'La' | "L'"
;

le_:
    'le' | 'la'
;

d_un_:
    'd' "'" ('une'|'un')
;

de_:
    "d'" | 'de'
;

du_:
    'du' | 'de' 'la'
;

Un_ :
    'Une' | 'Un'
;

un_ :
    'une' | 'un'
;

A_ :
    'A' | 'An'
;

a_ :
    'a' | 'an'
;



// ================== TextBlock grammar ===================================

OPTTB:
    ('{'
        textBlock = TextBlock
    '}')?
;

TextBlock:
     textLines *= TextLine
;

TextLine[noskipws]:
    /\s*\|/ textTokens *= TextToken /\|;/
;

TextToken:
      TextReference
    | PlainText
;

TextReference:
    '`' text=/[^`]*/ '`'
;

PlainText:
    text=/[^`\|]*/
;

Comment:
    /#.*$/
;

//  class model
//
//  // ---------------------------------------------
//  //
//
//
//  Class
//  =====
//  class <class.name>
//  Le concept de <class.name> est important.
//  <class.name> is an important concept.
//  "File" is an important concept.
//  Le concept de "Fichier" est important.
//
//  Inheritance
//  ===========
//  class <a.name> < <class.name>
//  A <class.name> is a <class.name>.
//  Un|Une <class.name> est un|une <class.name>.
//  A "PlainFile" is a "File".
//  Un "FichierPlein" est un "Fichier".
//
//  Attribute
//  =========
//  class <class.name>
//      <attribute.name> : <type.name>
//  The <attribute.name> of a <class.name> is a <type.name>.
//  Le|La|L' <attribute.name> d'un|d'une <class.name> est un|une <type.name>.
//  The "size" of a "PlainFile" is an "integer"
//  La taille d'un "FichierPlain" est un "entier"
//
//  Association
//  ===========
//
//  association name, role, cardinalite
//  -----------------------------------
//
//  association <association.name> ...
//      <role1.name> : <class1.name> [role1.card]
//      <role2.name> : <class2.name> [role2.card]
//
//  Cardinalities
//  '''''''''''''
//
//      [0..*]
//          zero or many
//          zero ou plusieurs
//      [1..*]
//          one or many
//          un|une ou plusieurs
//      [0..1]
//          zero or one
//          zero ou un|une
//      [1..1]
//          one
//          un
//      [x..y]
//          between x and y
//          entre x et y
//
//  Structure. Forward direction
//  ''''''''''''''''''''''''''''''''''
//  A <Class1.name> <association.name> [of] {role2.card} <role2.name> [of] type <Class2.name>.
//  Un|Une <Class1.name> <association.name> [de|d'] <role2.card> [de] <role2.name> de type <Class2.name>.
//  A "Person" "IsParent" of {zero or many} "children" of type "Person"
//  Un "Personne" "EstParent" de {zero ou plusieurs} "enfants" de type of type "Personne".
//
//  Structure. Reverse direction
//  ''''''''''''''''''''''''''''
//  A <Class2.name> has {role1.card} <role1.name> of type <class1.name>.
//  Une|Une <Class2.name> a {role1.card} <role1.name> de type <class1.name>
//  A "File" has {zero or one} "parent" of type "Directory"
//  Un "Fichier" a {zero ou un} "parent" de type "Directory
//
//  Constraints.
//  ''''''''''''
//
//  If <var2> is {role2.card} <role2.name> of a <Class1.name> <var1>
//      then <var1> is {role1.card} <role1.name> of [the <Class2.name>] <var2>
//  Si <var2> est {role2.card} <role2.name> d'un|d'une <Class1.name> <var1>
//      alors <var1> est {role1.card} <role1.name> de [le|la <Class2.name>] <var2>
//
//  The opposite constraints are necessary on both direction.
//
//  {Cardinalities}
//
//      [0/..1]
//          the
//          le|la
//      [0..*]
//          one of the
//          l'un|une des
//
//  example 1: assoc 11:
//      propriete : Maison[1]  <--> proprietaire : Personne[1]
//
//      If o is the "owner" of a "House" h
//          then h is the "property" of [the "Person"] o.
//      Si p est le "proprietaire" d'une "Maison" m
//          alors m est la "propriete" de [la "Personne"] p.
//
//  example 2: assoc nn:
//      maisonsVisitees : Maison[*] <--> visiteurs : Personne[*]
//
//      Si m est l'un des "maisonsVisitees" d'une Personne p
//          alors p est l'un des "visiteurs' de [la "Maison"] m.
//
//  0/..* -> Si h est l'un des "habitants" d'une "Maison" m alors m est le "lieuDeResidence" h.
//
//  Si v est la "ville" d'une Maison m alors m est l'une des "maisons" de la ville v
//  A CONTINER
//
//
//
//  Constraint. Association n-n
//  '''''''''''''''''''''''''''
//
//  Si f est l'un des "filmJoues" d'une person p alors p est l'un des acteurs de f [????et inversement???]]
//
//  Assoc 1-1
//
//  ---------------------
//
//  Le concept de "Fichier" est important.
//  Le concept de "FichierPlein" est important.
//  Le concept de "Repertoire" est important.
//  Le "nom" d'un "Fichier" est une chaine.
//  La "taille" d'un "fichier" est un entier.
//  Un "FichierPlein" est un "Fichier".
//  Un "Repertoire" est un "Fichier".
//  Un "Repertoire" "Contient " un nombre quelconque de "fichiers" de type "Fichier".
//  Un "Repertoire" a un nombre quelconque de "fichiers" de type "Fichier".
//  Un "Fichier" a un zero ou un "parent" de type "Repertoire"
//
//  Le concept de "Personne" est important.
//  Une "Personne" a entre 0 et deux "parents" de type "Personne".
//  Une "Personne" a un nombre quelconque d'"enfants" de type "Personne".
//  Une "Personne" "EstParent" d'un nombre quelconque d'"enfants" de type "Personne".
//  Les "enfants" d'une "Personne"
//  Les "parents" d'une Personne ont pour enfants cette personne.
//
//  Le concept de "Film" est important.
//
//  Film   --- EstRealisePar --- Personne
//  Une "Personne" a un nombre quelconque de "filmRealises" de type Film.
//  - Un "Film" a un "realisateur" de type "Personne".
//  - Un "Film" "EstRealisePar" un "realisateur" de type "Personne".
//  * Le "realisateur" d un "Film" f fait partie des "filmsRealises" de f.
//  * Les "filmsRealises" de une "Personne" x ont pour "realisateur" x.
//
//
//  Une personne a un nombre quelconque de filmJoues de type Film.
//  - Un Film a un nombre quelconque de acteur de type Personne.
//  - Un Film EstJouePar un nombre quelconque de
//
