

from typing import Optional, Text

import re

from modelscripts.interfaces.environment import Environment
from modelscripts.base.issues import (
    Levels,
    Issue,
    FatalError)
from modelscripts.base.grammars import (
    ASTNodeSourceIssue
)
from modelscripts.metamodels.classes import (
    ClassModel)
from modelscripts.scripts.classes.useprinter import (
    UsePrinter)
from modelscripts.tools.use.engine import USEEngine

ISSUES={
    'USE_OCL_ERROR': 'cl.fin.USE.ClassModelError',
}

def icode(ilabel):
    return ISSUES[ilabel]

class OCLChecker(object):

    def __init__(self, model):

        self.model=model
        #type: ClassModel

        self.usePrinter=None
        #type: Optional[UsePrinter]
        # Filled by check

    @property
    def useFileName(self):
        if self.model.source:
            cls_filename=self.model.source.fileName
            return Environment.getWorkerFileName(
                cls_filename,
                extension='.use',
                workerSpace='inline')
        else:
            raise NotImplemented('TODO: model with no source')

    def check(self):
        print('||'*20, 'CHECK', self.useFileName)
        if self.model.hasOCLCode:
            self.usePrinter = UsePrinter(self.model)
            self.usePrinter.do()
            self.usePrinter.save(self.useFileName)
            print('||'*20, ': .use generated')
            self._execute_use()

    def _execute_use(self):
        #--- execute USE OCL
        try:
            exit_code = USEEngine.analyzeUSEModel(
                self.useFileName,
                workerspace='self')
        except Exception as e:  # TODO: check what to do
            Issue(
                origin=self.model,
                level=Levels.Info,
                message='USE tool cannot be executed. OCL code will be ignored.')

            return

        #--- process errors if any
        if exit_code != 0:
            # create errors from the ouput generated by USE
            for error_line in USEEngine.err.splitlines():
                self._raise_issue_from_error(error_line)

    def _raise_issue_from_error(self, error_line):
        #type: (Text) -> None
        """
        Convert a USE error into issue.
        See example of USE error format at the end of this
        very file.
        """
        print('||'*10, error_line)


        p = r'^(?P<filename>.*)' \
            r'(:|:line | line )(?P<line>\d+):(?P<column>\d+)(:)?' \
            r'(?P<message>.+)$'
        m = re.match(p, error_line)
        if m:
            # sometimes the regexp fail.
            # e.g. with "ERROR oct. 11, 2015 3:57:00 PM java.util.pref ..."
            use_message = m.group('message')
            use_line = int(m.group('line'))
            use_column = int(m.group('column'))
            # cls_line=self.usePrinter.getCLSLine(use_line)
            element=self.usePrinter.getElement(use_line)
            if element is None or element.astNode is None:
                Issue(
                    origin=self.model,
                    level=Levels.Error,
                    message='USE tool says: "%s"' % error_line)
            else:
                ASTNodeSourceIssue(
                    code=icode('USE_OCL_ERROR'),
                    astNode=element.astNode,
                    level=Levels.Error,
                    message=use_message)

"""
======================
Examples of USE Errors
======================

testcases/useerrors/bart.use:line 27:26 no viable alternative at input '='
testcases/useerrors/empty.use:line 1:0 mismatched input '<EOF>' expecting 'model'
testcases/useerrors/model.use:line 1:5 mismatched input '<EOF>' expecting an identifier
testcases/useerrors/model.use:2:10: Undefined class `B'.
testcases/useerrors/card.use:line 4:4 extraneous input 'role' expecting [
testcases/useerrors/card1.use:4:5: Invalid multiplicity range `1..0'.
testcases/useerrors/card1.use:8:6: Class `C' cannot be a superclass of itself.

"""